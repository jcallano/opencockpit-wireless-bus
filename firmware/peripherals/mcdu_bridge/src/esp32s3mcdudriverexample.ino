#include <Arduino.h>
#include "usb/usb_host.h"
#include "usb/usb_helpers.h"

// ==========================================
// CONFIGURACIÓN HARDWARE
// ==========================================
#define RXD0        44
#define TXD0        43
#define USB_SEL     18  
#define DEV_VBUS_EN 12  
#define VBUS_EN_OTG 17  

#define MCDU_VID 0x4098
#define MCDU_PID 0xBB36

#define PACKET_PACING_MS 2 
#define TOTAL_BUFFER_SIZE 1024
#define ROWS 14
#define COLS 24
#define BYTES_PER_CHAR 3

// === COLORES WINWING (CRÍTICO: NO SON RGB ESTÁNDAR) ===
#define COLOR_BLACK   0x0000
#define COLOR_AMBER   0x0021
#define COLOR_WHITE   0x0042
#define COLOR_CYAN    0x0063
#define COLOR_GREEN   0x0084
#define COLOR_MAGENTA 0x00A5
#define COLOR_RED     0x00C6
#define COLOR_YELLOW  0x00E7

// ==========================================
// SECUENCIA DE INICIALIZACIÓN
// ==========================================
const uint8_t INIT_SEQ_RAW[][64] = {
    {0xf0, 0x0, 0x1, 0x38, 0x32, 0xbb, 0x0, 0x0, 0x1e, 0x1, 0x0, 0x0, 0xc4, 0x24, 0xa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x18, 0x1, 0x0, 0x0, 0xc4, 0x24, 0xa, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x34, 0x0, 0x18, 0x0, 0xe, 0x0, 0x18, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0xc4, 0x24, 0xa, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x0},
    {0xf0, 0x0, 0x2, 0x38, 0x0, 0x0, 0x0, 0x1, 0x0, 0x5, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0xc4, 0x24, 0xa, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x1, 0x0, 0x6, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
    {0xf0, 0x0, 0x3, 0x38, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0xff, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0xa5, 0xff, 0xff, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x0, 0x0},
    {0xf0, 0x0, 0x4, 0x38, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0xff, 0xff, 0xff, 0xff, 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0xff, 0xff, 0x0, 0xff, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
    {0xf0, 0x0, 0x5, 0x38, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x3d, 0xff, 0x0, 0xff, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0xff, 0x63, 0x0, 0x0, 0x0, 0x0},
    {0xf0, 0x0, 0x6, 0x38, 0xff, 0xff, 0x9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xff, 0xff, 0xa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x0, 0x0},
    {0xf0, 0x0, 0x7, 0x38, 0x0, 0x0, 0x2, 0x0, 0x0, 0xff, 0xff, 0xff, 0xb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x42, 0x5c, 0x61, 0xff, 0xc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x0, 0x0, 0x0, 0x0},
    {0xf0, 0x0, 0x8, 0x38, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x77, 0x77, 0x77, 0xff, 0xd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x5e, 0x73, 0x79, 0xff, 0xe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x0, 0x0, 0x0},
    {0xf0, 0x0, 0x9, 0x38, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x20, 0x20, 0x20, 0xff, 0xf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0xa5, 0xff, 0xff, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
    {0xf0, 0x0, 0xa, 0x38, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0xff, 0xff, 0xff, 0xff, 0x11, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0},
    {0xf0, 0x0, 0xb, 0x38, 0xff, 0x12, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x3d, 0xff, 0x0, 0xff, 0x13, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
    {0xf0, 0x0, 0xc, 0x38, 0x0, 0x3, 0x0, 0xff, 0x63, 0xff, 0xff, 0x14, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0xff, 0xff, 0x15, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x0, 0x0, 0x0, 0x0},
    {0xf0, 0x0, 0xd, 0x38, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0xff, 0xff, 0xff, 0x16, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x42, 0x5c, 0x61, 0xff, 0x17, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
    {0xf0, 0x0, 0xe, 0x38, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x77, 0x77, 0x77, 0xff, 0x18, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x5e, 0x73, 0x79, 0xff, 0x19, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
    {0xf0, 0x0, 0xf, 0x38, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x4, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
    {0xf0, 0x0, 0x10, 0x38, 0x1b, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x4, 0x0, 0x2, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x1a, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
    {0xf0, 0x0, 0x11, 0x12, 0x2, 0x32, 0xbb, 0x0, 0x0, 0x1c, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}
};
const uint8_t CMD_BRIGHTNESS[] = {0x02, 0x32, 0xbb, 0, 0, 3, 0x49, 0, 255, 0,0,0,0,0};

typedef enum { STATE_WAITING, STATE_CONNECTED, STATE_CONFIGURING, STATE_RUNNING } SystemState_t;
SystemState_t currentState = STATE_WAITING;

uint8_t displayBuffer[TOTAL_BUFFER_SIZE];
usb_host_client_handle_t client_hdl = NULL;
usb_device_handle_t mcdu_handle = NULL;
usb_transfer_t *out_xfer = NULL; 
usb_transfer_t *in_xfer = NULL;

uint8_t out_endpoint_addr = 0x00; 
uint8_t in_endpoint_addr = 0x81; 
volatile bool transfer_completed = true;

// ==========================================
// FUNCIONES BUFFER
// ==========================================
void clearBuffer() {
    for (int i = 0; i < TOTAL_BUFFER_SIZE; i += 3) {
        if (i + 2 < TOTAL_BUFFER_SIZE) {
            displayBuffer[i] = 0x42; displayBuffer[i+1] = 0x00; displayBuffer[i+2] = 0x20; 
        }
    }
}
void drawChar(int row, int col, char c, uint16_t color) {
    int offset = (row * COLS * BYTES_PER_CHAR) + (col * BYTES_PER_CHAR);
    if (offset + 2 >= TOTAL_BUFFER_SIZE) return;
    displayBuffer[offset] = color & 0xFF;
    displayBuffer[offset+1] = (color >> 8) & 0xFF;
    displayBuffer[offset+2] = c;
}

// ==========================================
// CALLBACK BOTONES
// ==========================================
uint8_t last_buttons[12] = {0}; 

void in_cb(usb_transfer_t *t) {
    if (t->status == USB_TRANSFER_STATUS_COMPLETED && t->actual_num_bytes >= 13) {
        bool change_detected = false;
        
        for (int i = 0; i < 12; i++) {
            uint8_t current_byte = t->data_buffer[i + 1];
            if (current_byte != last_buttons[i]) {
                for (int bit = 0; bit < 8; bit++) {
                    bool was_pressed = (last_buttons[i] >> bit) & 1;
                    bool is_pressed = (current_byte >> bit) & 1;
                    
                    if (is_pressed && !was_pressed) {
                        int button_id = (i * 8) + bit;
                        Serial0.printf("BOTON PULSADO: ID %d\n", button_id);
                        
                        char buf[5];
                        sprintf(buf, "%03d", button_id);
                        // AQUI ESTABA EL ERROR: USAR COLORES VALIDOS
                        drawChar(8, 10, buf[0], COLOR_RED);
                        drawChar(8, 11, buf[1], COLOR_RED);
                        drawChar(8, 12, buf[2], COLOR_RED);
                    }
                }
                last_buttons[i] = current_byte;
                change_detected = true;
            }
        }
    }
    
    if (mcdu_handle) {
        usb_host_transfer_submit(t);
    }
}

// ==========================================
// GESTIÓN USB - SALIDA
// ==========================================
void out_cb(usb_transfer_t *t) {
    transfer_completed = true;
}

void sendRawPacket(const uint8_t* data, size_t len) {
    if (!mcdu_handle || !out_xfer || out_endpoint_addr == 0) return;

    while(!transfer_completed) {
        usb_host_client_handle_events(client_hdl, 1);
        usb_host_lib_handle_events(1, NULL);
    }

    size_t sendLen = (len > 64) ? 64 : len;
    memcpy(out_xfer->data_buffer, data, sendLen);
    if (sendLen < 64) memset(out_xfer->data_buffer + sendLen, 0, 64 - sendLen);

    out_xfer->num_bytes = 64;
    out_xfer->device_handle = mcdu_handle;
    out_xfer->bEndpointAddress = out_endpoint_addr;
    out_xfer->callback = out_cb;

    transfer_completed = false;
    if (usb_host_transfer_submit(out_xfer) != ESP_OK) transfer_completed = true;

    while(!transfer_completed) {
        usb_host_client_handle_events(client_hdl, 1);
        usb_host_lib_handle_events(1, NULL);
    }
    delay(PACKET_PACING_MS); 
}

void flushDisplayBuffer() {
    int ptr = 0;
    uint8_t packet[64];
    while (ptr < TOTAL_BUFFER_SIZE) {
        int chunk_size = 63;
        if (TOTAL_BUFFER_SIZE - ptr < chunk_size) chunk_size = TOTAL_BUFFER_SIZE - ptr;
        packet[0] = 0xF2; 
        memcpy(&packet[1], &displayBuffer[ptr], chunk_size);
        sendRawPacket(packet, chunk_size + 1);
        ptr += chunk_size;
    }
}

// ==========================================
// SETUP
// ==========================================
void client_event_cb(const usb_host_client_event_msg_t *event_msg, void *arg) {
    if (event_msg->event == USB_HOST_CLIENT_EVENT_NEW_DEV) {
        usb_device_handle_t temp_handle;
        if (usb_host_device_open(client_hdl, event_msg->new_dev.address, &temp_handle) == ESP_OK) {
            const usb_device_desc_t *dev_desc;
            usb_host_get_device_descriptor(temp_handle, &dev_desc);

            if (dev_desc->idVendor == MCDU_VID && dev_desc->idProduct == MCDU_PID) {
                Serial0.println(">>> MCDU CONECTADA <<<");
                usb_host_interface_claim(client_hdl, temp_handle, 0, 0);
                
                const usb_config_desc_t *config_desc;
                usb_host_get_active_config_descriptor(temp_handle, &config_desc);
                int offset = 0;
                const usb_intf_desc_t *intf = usb_parse_interface_descriptor(config_desc, 0, 0, &offset);
                
                if (intf) {
                    for (int i = 0; i < intf->bNumEndpoints; i++) {
                        int ep_offset = 0;
                        const usb_ep_desc_t *ep = usb_parse_endpoint_descriptor_by_index(intf, i, config_desc->wTotalLength, &ep_offset);
                        if (ep && (ep->bEndpointAddress & 0x80) == 0) out_endpoint_addr = ep->bEndpointAddress;
                        if (ep && (ep->bEndpointAddress & 0x80) != 0) in_endpoint_addr = ep->bEndpointAddress;
                    }
                }
                if (out_endpoint_addr == 0) out_endpoint_addr = 0x02; 
                if (in_endpoint_addr == 0) in_endpoint_addr = 0x81;

                mcdu_handle = temp_handle;
                
                in_xfer->device_handle = mcdu_handle;
                in_xfer->bEndpointAddress = in_endpoint_addr;
                in_xfer->num_bytes = 64; 
                in_xfer->callback = in_cb;
                usb_host_transfer_submit(in_xfer);

                currentState = STATE_CONNECTED;
            } else {
                usb_host_device_close(client_hdl, temp_handle);
            }
        }
    }
}

void setup() {
    Serial0.begin(115200, SERIAL_8N1, RXD0, TXD0);
    delay(500);

    pinMode(USB_SEL, OUTPUT);     digitalWrite(USB_SEL, HIGH);
    pinMode(DEV_VBUS_EN, OUTPUT); digitalWrite(DEV_VBUS_EN, HIGH);
    pinMode(VBUS_EN_OTG, OUTPUT); digitalWrite(VBUS_EN_OTG, HIGH);
    delay(1000); 

    const usb_host_config_t h_cfg = { .intr_flags = ESP_INTR_FLAG_LEVEL1 };
    usb_host_install(&h_cfg);
    static usb_host_client_config_t c_cfg = { .is_synchronous = false, .max_num_event_msg = 10,
        .async = { .client_event_callback = client_event_cb, .callback_arg = NULL } };
    usb_host_client_register(&c_cfg, &client_hdl);
    
    usb_host_transfer_alloc(64, 0, &out_xfer);
    usb_host_transfer_alloc(64, 0, &in_xfer);
    clearBuffer();
}

void loop() {
    uint32_t f; usb_host_lib_handle_events(1, &f);
    if (client_hdl) usb_host_client_handle_events(client_hdl, 1);

    switch (currentState) {
        case STATE_CONNECTED:
            Serial0.println("Configurando...");
            currentState = STATE_CONFIGURING;
            for (int i=0; i < 17; i++) sendRawPacket(INIT_SEQ_RAW[i], 64);
            delay(50);
            sendRawPacket(CMD_BRIGHTNESS, sizeof(CMD_BRIGHTNESS));
            delay(50);
            sendRawPacket(CMD_BRIGHTNESS, sizeof(CMD_BRIGHTNESS));
            
            drawChar(2, 2, 'K', COLOR_GREEN);
            drawChar(2, 3, 'E', COLOR_GREEN);
            drawChar(2, 4, 'Y', COLOR_GREEN);
            drawChar(2, 5, 'S', COLOR_GREEN);
            drawChar(6, 6, 'I', COLOR_GREEN);
            drawChar(6, 7, 'D', COLOR_GREEN);
            drawChar(6, 8, ':', COLOR_GREEN);
            
            currentState = STATE_RUNNING;
            break;

        case STATE_RUNNING:
            static unsigned long lastUpdate = 0;
            if (millis() - lastUpdate > 100) {
                flushDisplayBuffer();
                lastUpdate = millis();
            }
            break;
    }
}