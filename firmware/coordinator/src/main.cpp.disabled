/**
 * OpenCockpit Wireless Avionics Bus
 * Node A - Coordinator (CDC + SLIP)
 *
 * - USB CDC (SLIP framing) to PC
 * - ESP-NOW coordinator to peripheral nodes
 * - LCD metrics (messages/sec)
 */

#include <Arduino.h>
#include <SPI.h>
#include "USB.h"
#include "USBCDC.h"

#include "../common/slip.h"
#include "include/espnow_coordinator.h"

// ------------------------------------------------------------
// ESP32-S3-USB-OTG board pins (from Espressif reference)
// ------------------------------------------------------------
#define USB_SEL_PIN         18  // High: route D+/D- to USB_DEV -> USB_HOST port
#define USB_D_MINUS_PIN     19
#define USB_D_PLUS_PIN      20

#define LIMIT_EN_PIN        17  // Enable current limit IC (USB_HOST power)
#define DEV_VBUS_EN_PIN     12  // Enable DEV_VBUS (USB_HOST power)
#define BOOST_EN_PIN        13  // Enable boost (battery to 5V for USB_HOST)

#define LCD_RST_PIN         8   // LCD_RET (active low)
#define LCD_EN_PIN          5   // LCD_EN (active low)
#define LCD_DC_PIN          4
#define LCD_SCLK_PIN        6
#define LCD_MOSI_PIN        7
#define LCD_BL_PIN          9

// ------------------------------------------------------------
// LCD parameters (ST7789, 240x240)
// ------------------------------------------------------------
#define LCD_WIDTH           240
#define LCD_HEIGHT          240

#define COLOR_BLACK         0x0000
#define COLOR_WHITE         0xFFFF
#define COLOR_GREEN         0x07E0
#define COLOR_CYAN          0x07FF
#define COLOR_YELLOW        0xFFE0

static SPIClass lcd_spi(FSPI);
static SPISettings lcd_spi_settings(40000000, MSBFIRST, SPI_MODE0);

// ------------------------------------------------------------
// USB CDC (SLIP)
// ------------------------------------------------------------
static USBCDC serialCDC;
static SlipDecoder slip_decoder;

// ------------------------------------------------------------
// Metrics
// ------------------------------------------------------------
static volatile uint32_t g_slip_rx_frames = 0;
static volatile uint32_t g_slip_tx_frames = 0;
static volatile uint32_t g_esp_rx_frames = 0;
static volatile uint32_t g_esp_tx_frames = 0;

// ------------------------------------------------------------
// Font (5x7)
// ------------------------------------------------------------
static const uint8_t kFont5x7[] = {
    0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x5F,0x00,0x00, 0x00,0x07,0x00,0x07,0x00,
    0x14,0x7F,0x14,0x7F,0x14, 0x24,0x2A,0x7F,0x2A,0x12, 0x23,0x13,0x08,0x64,0x62,
    0x36,0x49,0x55,0x22,0x50, 0x00,0x05,0x03,0x00,0x00, 0x00,0x1C,0x22,0x41,0x00,
    0x00,0x41,0x22,0x1C,0x00, 0x14,0x08,0x3E,0x08,0x14, 0x08,0x08,0x3E,0x08,0x08,
    0x00,0x50,0x30,0x00,0x00, 0x08,0x08,0x08,0x08,0x08, 0x00,0x60,0x60,0x00,0x00,
    0x20,0x10,0x08,0x04,0x02, 0x3E,0x51,0x49,0x45,0x3E, 0x00,0x42,0x7F,0x40,0x00,
    0x42,0x61,0x51,0x49,0x46, 0x21,0x41,0x45,0x4B,0x31, 0x18,0x14,0x12,0x7F,0x10,
    0x27,0x45,0x45,0x45,0x39, 0x3C,0x4A,0x49,0x49,0x30, 0x01,0x71,0x09,0x05,0x03,
    0x36,0x49,0x49,0x49,0x36, 0x06,0x49,0x49,0x29,0x1E, 0x00,0x36,0x36,0x00,0x00,
    0x00,0x56,0x36,0x00,0x00, 0x08,0x14,0x22,0x41,0x00, 0x14,0x14,0x14,0x14,0x14,
    0x00,0x41,0x22,0x14,0x08, 0x02,0x01,0x51,0x09,0x06, 0x32,0x49,0x79,0x41,0x3E,
    0x7E,0x11,0x11,0x11,0x7E, 0x7F,0x49,0x49,0x49,0x36, 0x3E,0x41,0x41,0x41,0x22,
    0x7F,0x41,0x41,0x22,0x1C, 0x7F,0x49,0x49,0x49,0x41, 0x7F,0x09,0x09,0x09,0x01,
    0x3E,0x41,0x49,0x49,0x7A, 0x7F,0x08,0x08,0x08,0x7F, 0x00,0x41,0x7F,0x41,0x00,
    0x20,0x40,0x41,0x3F,0x01, 0x7F,0x08,0x14,0x22,0x41, 0x7F,0x40,0x40,0x40,0x40,
    0x7F,0x02,0x0C,0x02,0x7F, 0x7F,0x04,0x08,0x10,0x7F, 0x3E,0x41,0x41,0x41,0x3E,
    0x7F,0x09,0x09,0x09,0x06, 0x3E,0x41,0x51,0x21,0x5E, 0x7F,0x09,0x19,0x29,0x46,
    0x46,0x49,0x49,0x49,0x31, 0x01,0x01,0x7F,0x01,0x01, 0x3F,0x40,0x40,0x40,0x3F,
    0x1F,0x20,0x40,0x20,0x1F, 0x3F,0x40,0x38,0x40,0x3F, 0x63,0x14,0x08,0x14,0x63,
    0x07,0x08,0x70,0x08,0x07, 0x61,0x51,0x49,0x45,0x43, 0x00,0x7F,0x41,0x41,0x00,
    0x02,0x04,0x08,0x10,0x20, 0x00,0x41,0x41,0x7F,0x00, 0x04,0x02,0x01,0x02,0x04,
    0x40,0x40,0x40,0x40,0x40, 0x00,0x01,0x02,0x04,0x00, 0x20,0x54,0x54,0x54,0x78,
    0x7F,0x48,0x44,0x44,0x38, 0x38,0x44,0x44,0x44,0x20, 0x38,0x44,0x44,0x48,0x7F,
    0x38,0x54,0x54,0x54,0x18, 0x08,0x7E,0x09,0x01,0x02, 0x08,0x14,0x54,0x54,0x3C,
    0x7F,0x08,0x04,0x04,0x78, 0x00,0x44,0x7D,0x40,0x00, 0x20,0x40,0x44,0x3D,0x00,
    0x7F,0x10,0x28,0x44,0x00, 0x00,0x41,0x7F,0x40,0x00, 0x7C,0x04,0x18,0x04,0x78,
    0x7C,0x08,0x04,0x04,0x78, 0x38,0x44,0x44,0x44,0x38, 0x7C,0x14,0x14,0x14,0x08,
    0x08,0x14,0x14,0x18,0x7C, 0x7C,0x08,0x04,0x04,0x08, 0x48,0x54,0x54,0x54,0x20,
    0x04,0x3F,0x44,0x40,0x20, 0x3C,0x40,0x40,0x20,0x7C, 0x1C,0x20,0x40,0x20,0x1C,
    0x3C,0x40,0x30,0x40,0x3C, 0x44,0x28,0x10,0x28,0x44, 0x0C,0x50,0x50,0x50,0x3C,
    0x44,0x64,0x54,0x4C,0x44, 0x00,0x08,0x36,0x41,0x00, 0x00,0x00,0x7F,0x00,0x00,
    0x00,0x41,0x36,0x08,0x00, 0x08,0x08,0x2A,0x1C,0x08, 0x08,0x1C,0x2A,0x08,0x08
};

// ------------------------------------------------------------
// LCD helpers
// ------------------------------------------------------------
static void lcd_write_cmd(uint8_t cmd) {
    digitalWrite(LCD_DC_PIN, LOW);
    lcd_spi.beginTransaction(lcd_spi_settings);
    lcd_spi.write(cmd);
    lcd_spi.endTransaction();
}

static void lcd_write_data(const uint8_t* data, size_t len) {
    digitalWrite(LCD_DC_PIN, HIGH);
    lcd_spi.beginTransaction(lcd_spi_settings);
    lcd_spi.writeBytes(data, len);
    lcd_spi.endTransaction();
}

static void lcd_write_data8(uint8_t data) {
    lcd_write_data(&data, 1);
}

static void lcd_write_data16(uint16_t data) {
    uint8_t buf[2] = {static_cast<uint8_t>(data >> 8), static_cast<uint8_t>(data & 0xFF)};
    lcd_write_data(buf, sizeof(buf));
}

static void lcd_set_window(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1) {
    lcd_write_cmd(0x2A);
    lcd_write_data16(x0);
    lcd_write_data16(x1);
    lcd_write_cmd(0x2B);
    lcd_write_data16(y0);
    lcd_write_data16(y1);
    lcd_write_cmd(0x2C);
}

static void lcd_fill_rect(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color) {
    if (x >= LCD_WIDTH || y >= LCD_HEIGHT) return;
    if (x + w > LCD_WIDTH) w = LCD_WIDTH - x;
    if (y + h > LCD_HEIGHT) h = LCD_HEIGHT - y;

    lcd_set_window(x, y, x + w - 1, y + h - 1);
    digitalWrite(LCD_DC_PIN, HIGH);
    lcd_spi.beginTransaction(lcd_spi_settings);
    for (uint32_t i = 0; i < static_cast<uint32_t>(w) * h; i++) {
        lcd_spi.write16(color);
    }
    lcd_spi.endTransaction();
}

static void lcd_fill_screen(uint16_t color) {
    lcd_fill_rect(0, 0, LCD_WIDTH, LCD_HEIGHT, color);
}

static void lcd_draw_char(uint16_t x, uint16_t y, char c, uint16_t color, uint16_t bg, uint8_t scale) {
    if (c < 0x20 || c > 0x7E) c = '?';
    uint16_t idx = (c - 0x20) * 5;

    for (uint8_t col = 0; col < 5; col++) {
        uint8_t line = kFont5x7[idx + col];
        for (uint8_t row = 0; row < 7; row++) {
            uint16_t px = x + col * scale;
            uint16_t py = y + row * scale;
            uint16_t draw_color = (line & 0x01) ? color : bg;
            if (scale == 1) {
                lcd_fill_rect(px, py, 1, 1, draw_color);
            } else {
                lcd_fill_rect(px, py, scale, scale, draw_color);
            }
            line >>= 1;
        }
    }
}

static void lcd_draw_text(uint16_t x, uint16_t y, const char* text, uint16_t color, uint16_t bg, uint8_t scale) {
    while (*text) {
        lcd_draw_char(x, y, *text, color, bg, scale);
        x += 6 * scale;
        text++;
    }
}

static void lcd_init() {
    pinMode(LCD_RST_PIN, OUTPUT);
    pinMode(LCD_EN_PIN, OUTPUT);
    pinMode(LCD_DC_PIN, OUTPUT);
    pinMode(LCD_BL_PIN, OUTPUT);

    digitalWrite(LCD_EN_PIN, LOW);
    digitalWrite(LCD_BL_PIN, HIGH);

    lcd_spi.begin(LCD_SCLK_PIN, -1, LCD_MOSI_PIN, -1);

    digitalWrite(LCD_RST_PIN, LOW);
    delay(20);
    digitalWrite(LCD_RST_PIN, HIGH);
    delay(120);

    lcd_write_cmd(0x01); // SWRESET
    delay(150);
    lcd_write_cmd(0x11); // SLPOUT
    delay(120);
    lcd_write_cmd(0x3A); // COLMOD
    lcd_write_data8(0x55);
    lcd_write_cmd(0x36); // MADCTL
    lcd_write_data8(0x00);
    lcd_write_cmd(0x21); // INVON
    lcd_write_cmd(0x13); // NORON
    lcd_write_cmd(0x29); // DISPON
    delay(20);

    lcd_fill_screen(COLOR_BLACK);
}

// ------------------------------------------------------------
// SLIP -> ESP-NOW routing
// ------------------------------------------------------------
static void handle_slip_frame(const uint8_t* data, size_t len) {
    if (!validateMessage(data, len)) {
        return;
    }

    const MessageHeader* hdr = reinterpret_cast<const MessageHeader*>(data);
    const uint8_t* payload = data + sizeof(MessageHeader);
    size_t payload_len = len - sizeof(MessageHeader) - 1;

    if (hdr->dst_node == NODE_COORDINATOR) {
        if (hdr->msg_type == MSG_RESET) {
            ESP.restart();
        }
        return;
    }

    switch (hdr->msg_type) {
        case MSG_HID_OUTPUT: {
            if (payload_len < 3) break;
            const HIDOutputPayload* out = reinterpret_cast<const HIDOutputPayload*>(payload);
            if (payload_len < static_cast<size_t>(3 + out->report_length)) break;
            if (coordinator.sendHIDOutput(hdr->dst_node, out->device_id,
                                          out->report_data, out->report_length)) {
                g_esp_tx_frames++;
            }
            break;
        }
        case MSG_SERIAL_DATA: {
            if (payload_len < 2) break;
            const SerialDataPayload* serial = reinterpret_cast<const SerialDataPayload*>(payload);
            if (payload_len < static_cast<size_t>(2 + serial->data_length)) break;
            if (coordinator.sendSerialData(hdr->dst_node, serial->port_id,
                                           serial->data, serial->data_length)) {
                g_esp_tx_frames++;
            }
            break;
        }
        case MSG_MCDU_DISPLAY: {
            if (payload_len == 0) break;
            if (coordinator.sendMCDUDisplay(hdr->dst_node, payload,
                                            static_cast<uint8_t>(payload_len))) {
                g_esp_tx_frames++;
            }
            break;
        }
        case MSG_DISCOVERY_REQ: {
            for (uint8_t id = NODE_B_JOYSTICK; id < NODE_BROADCAST; id++) {
                const PeerInfo* peer = coordinator.getPeerInfo(id);
                if (!peer) continue;
                DiscoveryResponse rsp = {};
                rsp.node_type = peer->node_type;
                rsp.capabilities = peer->capabilities;
                rsp.device_count = peer->device_count;
                memcpy(rsp.mac_address, peer->mac_address, sizeof(rsp.mac_address));
                strncpy(rsp.firmware_version, "n/a", FIRMWARE_VERSION_SIZE - 1);
                strncpy(rsp.node_name, peer->node_name, MAX_NODE_NAME_SIZE - 1);

                uint8_t buffer[MAX_ESPNOW_PAYLOAD];
                size_t msg_len = buildMessage(buffer, MSG_DISCOVERY_RSP, peer->node_id,
                                              NODE_COORDINATOR, &rsp, sizeof(rsp));
                slip_send(buffer, msg_len, serialCDC);
                g_slip_tx_frames++;
            }
            break;
        }
        default:
            break;
    }
}

static void process_slip_rx() {
    while (serialCDC.available()) {
        uint8_t byte = serialCDC.read();
        if (slip_decode_byte(&slip_decoder, byte)) {
            size_t len = slip_decoder.index;
            g_slip_rx_frames++;
            handle_slip_frame(slip_decoder.buffer, len);
            slip_decoder_reset(&slip_decoder);
        }
    }
}

static void send_to_pc(uint8_t msg_type, uint8_t src_node, const void* payload, size_t payload_len) {
    uint8_t buffer[MAX_ESPNOW_PAYLOAD];
    size_t len = buildMessage(buffer, static_cast<MessageType>(msg_type),
                              src_node, NODE_COORDINATOR, payload, payload_len);
    slip_send(buffer, len, serialCDC);
    g_slip_tx_frames++;
}

// ------------------------------------------------------------
// ESP-NOW callbacks
// ------------------------------------------------------------
static void onHIDInput(uint8_t node_id, uint8_t device_id, uint8_t report_id,
                       const uint8_t* report, uint8_t len) {
    if (len > MAX_HID_REPORT_SIZE) {
        len = MAX_HID_REPORT_SIZE;
    }
    HIDInputPayload payload = {};
    payload.device_id = device_id;
    payload.report_id = report_id;
    payload.report_length = len;
    memcpy(payload.report_data, report, len);
    send_to_pc(MSG_HID_INPUT, node_id, &payload, 3 + len);
    g_esp_rx_frames++;
}

static void onSerialData(uint8_t node_id, uint8_t port_id, const uint8_t* data, uint8_t len) {
    if (len > MAX_SERIAL_DATA_SIZE) {
        len = MAX_SERIAL_DATA_SIZE;
    }
    SerialDataPayload payload = {};
    payload.port_id = port_id;
    payload.data_length = len;
    memcpy(payload.data, data, len);
    send_to_pc(MSG_SERIAL_DATA, node_id, &payload, 2 + len);
    g_esp_rx_frames++;
}

static void onNodeStatus(uint8_t node_id, bool connected) {
    if (!connected) {
        return;
    }
    const PeerInfo* peer = coordinator.getPeerInfo(node_id);
    if (!peer) {
        return;
    }
    DiscoveryResponse rsp = {};
    rsp.node_type = peer->node_type;
    rsp.capabilities = peer->capabilities;
    rsp.device_count = peer->device_count;
    memcpy(rsp.mac_address, peer->mac_address, sizeof(rsp.mac_address));
    strncpy(rsp.firmware_version, "n/a", FIRMWARE_VERSION_SIZE - 1);
    strncpy(rsp.node_name, peer->node_name, MAX_NODE_NAME_SIZE - 1);
    send_to_pc(MSG_DISCOVERY_RSP, node_id, &rsp, sizeof(rsp));
}

// ------------------------------------------------------------
// Tasks
// ------------------------------------------------------------
static void espnow_task(void* parameter) {
    (void)parameter;
    while (true) {
        coordinator.process();
        vTaskDelay(pdMS_TO_TICKS(1));
    }
}

// ------------------------------------------------------------
// Setup
// ------------------------------------------------------------
void setup() {
    Serial0.begin(115200);
    delay(500);
    Serial0.println("\n=== Node A: Coordinator (CDC+SLIP) ===");

    pinMode(USB_SEL_PIN, OUTPUT);
    digitalWrite(USB_SEL_PIN, LOW); // Device mode (USB_DEV port to PC)

    pinMode(DEV_VBUS_EN_PIN, OUTPUT);
    pinMode(BOOST_EN_PIN, OUTPUT);
    pinMode(LIMIT_EN_PIN, OUTPUT);
    digitalWrite(DEV_VBUS_EN_PIN, LOW);
    digitalWrite(BOOST_EN_PIN, LOW);
    digitalWrite(LIMIT_EN_PIN, LOW);

    USB.productName("OpenCockpit Wireless Bridge");
    USB.manufacturerName("OpenCockpit");
    USB.serialNumber("OC-A-001");

    serialCDC.begin(115200);
    USB.begin();

    slip_decoder_init(&slip_decoder);

    lcd_init();
    lcd_draw_text(10, 10, "OC WIRELESS BUS", COLOR_CYAN, COLOR_BLACK, 2);

    Serial0.println("Initializing ESP-NOW Coordinator...");
    if (!coordinator.begin()) {
        Serial0.println("ERROR: Failed to initialize coordinator!");
        while (true) {
            delay(1000);
        }
    }

    coordinator.setHIDInputCallback(onHIDInput);
    coordinator.setSerialDataCallback(onSerialData);
    coordinator.setNodeStatusCallback(onNodeStatus);

    xTaskCreatePinnedToCore(espnow_task, "espnow_task", 4096, nullptr, 24, nullptr, 0);
}

// ------------------------------------------------------------
// Loop
// ------------------------------------------------------------
void loop() {
    process_slip_rx();

    static uint32_t last_stats_ms = 0;
    static uint32_t last_slip_rx = 0;
    static uint32_t last_slip_tx = 0;
    static uint32_t last_esp_rx = 0;
    static uint32_t last_esp_tx = 0;

    uint32_t now = millis();
    if (now - last_stats_ms >= 1000) {
        uint32_t slip_rx = g_slip_rx_frames;
        uint32_t slip_tx = g_slip_tx_frames;
        uint32_t esp_rx = g_esp_rx_frames;
        uint32_t esp_tx = g_esp_tx_frames;

        uint32_t slip_rx_rate = slip_rx - last_slip_rx;
        uint32_t slip_tx_rate = slip_tx - last_slip_tx;
        uint32_t esp_rx_rate = esp_rx - last_esp_rx;
        uint32_t esp_tx_rate = esp_tx - last_esp_tx;

        last_slip_rx = slip_rx;
        last_slip_tx = slip_tx;
        last_esp_rx = esp_rx;
        last_esp_tx = esp_tx;
        last_stats_ms = now;

        char line1[32];
        char line2[32];
        char line3[32];
        char line4[32];

        snprintf(line1, sizeof(line1), "SLIP RX: %lu/s", static_cast<unsigned long>(slip_rx_rate));
        snprintf(line2, sizeof(line2), "SLIP TX: %lu/s", static_cast<unsigned long>(slip_tx_rate));
        snprintf(line3, sizeof(line3), "ESPN RX: %lu/s", static_cast<unsigned long>(esp_rx_rate));
        snprintf(line4, sizeof(line4), "ESPN TX: %lu/s", static_cast<unsigned long>(esp_tx_rate));

        lcd_fill_rect(0, 40, LCD_WIDTH, 80, COLOR_BLACK);
        lcd_draw_text(10, 45, line1, COLOR_GREEN, COLOR_BLACK, 2);
        lcd_draw_text(10, 65, line2, COLOR_GREEN, COLOR_BLACK, 2);
        lcd_draw_text(10, 85, line3, COLOR_YELLOW, COLOR_BLACK, 2);
        lcd_draw_text(10, 105, line4, COLOR_YELLOW, COLOR_BLACK, 2);

        uint8_t nodes = coordinator.getConnectedNodeCount();
        char line5[32];
        snprintf(line5, sizeof(line5), "NODES: %u", nodes);
        lcd_fill_rect(0, 140, LCD_WIDTH, 20, COLOR_BLACK);
        lcd_draw_text(10, 145, line5, COLOR_CYAN, COLOR_BLACK, 2);
    }

    delay(1);
}
